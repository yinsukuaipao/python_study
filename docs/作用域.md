# 作用域

## 作用域

作者：知乎用户
链接：https://www.zhihu.com/question/22466764/answer/21464993
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Python 的作用域遵循一个叫做LEGB的法则。当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）使用 class, def, lambda 会引入一个本地作用域（Local），而且本地作用域是可以嵌套的。内层的变量会屏蔽外层，内层找不到的变量会去外层找全局作用域（Global）就是模块内的作用域，他的作用范围是单一文件内。内置函数的作用域就是int(), list()之类的内置函数。举个栗子：a1 = 1 # Global

class Foo:
    a2 = 1 # Local

    def func():
        a3 = 1 # Local
        def _func():
            a5 = 1 # Local
        for i in range(3):
            a4 = 1 # Local 和 a3 在同一个作用域，因为 for 不会引入新的作用域上述代码中作用域的范围是 a1 > a2 > a3 == a4 > a5PS：你也可以使用 global 语句 和 nonlocal 语句来改变他们的作用域

### 函数内部引用全局对象 global

```python
>>> a = 0
>>> b = 0
>>> def f():
...     global a # 此时的a就是全局的a
...     a = 1
...     b = 1 # 因为没有用global，这里的b就是局部对象
... 
>>> f()
>>> a   # a被修改了
1
>>> b   # b没有没有被修改
0
```

### 内部函数的值给外部函数的局部变量重新赋值 nonlocal（仅python3适用）

```python
>>> def f1():
...     a = 0
...     b = 0
...     def f2():
...             nonlocal a # 此时的a为外层函数的a
...             a = 1
...             b = 1 # 因为没有用global，这里的b就是f2的局部对象
...     f2()
...     print(a) # a发生了变化
...     print(b) # b没有变化
... 
>>> f1()
1
0
```

## 引用计数与垃圾回收

所有对象都有引用计数。给一个对象分配一个新名称，或者放入一个容器（列表、元组，字典等），都会增加该引用计数.

使用del语句或者引用超出作用域（或者被重新赋值），对象的引用计数会减少

del a

b = 42

## 引用与复制

python中的a=b这样的赋值，就会创建一个对b的新引用，所以对于可变对象，列表和字典这种，如果对b进行修改（如a[0] = 100）也会影响a的改变。

对于像数字，字符串这种不可变对象，像下面这种赋值

```python
b = 1
a = b
b = 2
```

感觉好像是b的修改不影响a的，其实仔细想，因为“=”是赋值操作，python的赋值操作是创建引用，所以b其实是指向了2这个新的引用。

