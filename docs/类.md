# 类

## 创建和使用类

### 定义

```python
class Add():  # 首字母大写
    def __init__(self, a, b):  # 构造函数 self为实例指针
        self.a = a
        self.b = b
        self.c = a + b
    
    def result(self):
        self.c = self.a + self.b
        return self.a + self.b

a = Add(1,2)
a.a = 0  # 属性访问
print(a.result())  # 2  调用方法
print(a.c)  # 2
```

```python
class Add():  # 首字母大写
    pass
```


python2.7 创建类要加object

```python
class Add(object):
```

### 实例变量动态绑定属性

只影响当前实例

```python
>>> a = Add(1, 2)
>>> a.x = 10
>>> print(a.x)
10
>>> b = Add(1, 2)
>>> print(b.x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Add' object has no attribute 'x'
```

### 私有变量

如果要让内部属性不被外部访问，可以把 **属性的名称前加上两个下划线__**

```python
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
```

双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量

最后注意下面的这种错误写法：

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.get_name()
'Bart Simpson'
>>> bart.__name = 'New Name' # 设置__name变量！
>>> bart.__name
'New Name'
```

表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。

```python
>>> bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
```

需要注意的是，在Python中，变量名类似 **\_\_xxx__** 的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，尽量不用__name__、__score__这样的变量名。

### 内部变量

\_\_xxx__

比如__len__方法返回长度，如果调用len()函数试图获取一个对象的长度，实际调用的就是类内部的__len__方法